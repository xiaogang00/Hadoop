* static的含义，static方法就是没有this的方法，在内部不能调用非静态方法。Java中禁止使用全局方法，但是在类中置入static方法就可以访问其他static方法和域。

* 垃圾回收器只能释放那些经由new分配的内存，所以不用new来分配的内存是特殊的。Java在这里允许在类中定义一个名为finalize()的方法。一旦垃圾回收器准备好释放对象占用的储存空间，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生的时候，才会真正回收对象占用的内存。使用finalize()就可以在垃圾回收时刻做一些重要的清理工作。

  在c++中对象一定会被销毁。但是在Java中对象可能不被垃圾回收，垃圾回收也不等于析构。这意味着如果你不再需要某个对象之前，如果必须执行某些动作，那么必须自己去做。



* finalize()的用途何在？我们应该注意到垃圾回收只与内存有关。所以对于与垃圾回收有关的任何行为来说，他们必须同内存以及回收有关。Java不允许构建局部的对象，必须使用new创建对象。Java采用的是一种自适应的垃圾回收技术。一般都是将内存从一处复制到另外一处，当然垃圾的内存是不会复制过去的。而且如果没有新的垃圾产生，那么就会进入另外一种工作模式，也就是标记-清扫。从堆栈和静态存储区出发，遍历所有的引用，进而找出所有存活的对象，并且给对象一个标记，当所有的标记都完成的时候，清理的动作才会开始。

* 如何发现活的对象。那就是从堆栈和静态存储区开始，遍历所有的引用，找到所有活的对象，对于发现的每个引用，必须追踪它所引用的对象，然后是此对象包含的所有引用。如此反复进行。"复制式回收器"一般都需要两个堆。

* 成员初始化。在类里面定义一个对象引用时候，如果不将其初始化，此引用就会获得一个特殊值null。

* 构造器初始化，可以使用构造器来进行初始化，可以调用方法或者执行某些动作来确定初值。但是无法阻止自动初始化的进行。静态数据的初始化：如果是基本类型就是得到标准初值，如果是一个对象引用，那么它的初始值就是null。

* 初始化的顺序是先静态对象，然后是非静态对象。构造器实际上是静态的方法。

* Integer是一个类而不是基本类型。

* 包的文件的命名如何做到独一无二：

  ```java
  package net.mindview.simple
  ```

* 无论何时创建包的时候，都已经在给定包的名称的时候隐含地指定了目录结构。这个包必须位于其名称所指定的目录之中。而且该目录必须是在以CLASSPATH开始的目录中可以查询到的。

* Java中包的访问权限，在没有加上任何访问权限修饰词的时候，默认当前的包中的所以其他类对那个成员都有访问权限，但是对于这个包之外的所有类，这个成员却是private。

* public：接口访问权限。使用关键字public，意味着public之后紧跟着的成员声明自己对每个人都是可用的。